#include <Windows.h>

HINSTANCE hInst;
HWND hWnd;
HCURSOR hCursorArrow; // È­»ìÇ¥ Ä¿¼­ ÇÚµé
COLORREF viewColor = RGB(255, 240, 200);
HBRUSH hBackgroundBrush; // ¹è°æ»ö ºê·¯½Ã
HPEN hBorderPen;        // Å×µÎ¸® Ææ

bool isBoxVisible = false;
bool isPressSpace = false;
bool isDrawing = false; // ±×¸² ±×¸®±â ÁøÇà ¿©ºÎ¸¦ ³ªÅ¸³»´Â ÇÃ·¡±×
POINT startPoint;
POINT endPoint;
// ¹öÆ° ½Äº°ÀÚ
#define BUTTON_ID_1 1001
#define BUTTON_ID_2 1002
#define BUTTON_ID_3 1003
#define BUTTON_ID_4 1004
#define BUTTON_ID_5 1005

void drawbonobono(HWND hWnd, HDC hdc) {
    RECT circle;
    GetClientRect(hWnd, &circle);

    int moveRight = 110; //¿À¸¥ÂÊÀ¸·Î ÀÌµ¿ÇÒ ÇÈ¼¿ ¼ö
    int moveDown = 25; // ¾Æ·¡·Î ÀÌµ¿ÇÒ ÇÈ¼¿ ¼ö
    float scale = 0.8; // º¸³ëº¸³ëÀÇ Å©±â¸¦ Á¶ÀýÇÏ±â À§ÇÑ ºñÀ²

    if (isBoxVisible) {
        HPEN hPen = CreatePen(PS_SOLID, 2, RGB(0, 0, 0));
        HPEN hOldPen = (HPEN)SelectObject(hdc, hPen);
        HBRUSH face = CreateSolidBrush(RGB(127, 200, 255));
        HBRUSH black = CreateSolidBrush(RGB(0, 0, 0));
        HBRUSH white = CreateSolidBrush(RGB(255, 255, 255));
        HBRUSH mouse = CreateSolidBrush(RGB(255, 150, 255));
        SelectObject(hdc, face);
        Ellipse(hdc, (int)(150 * scale) + moveRight, (int)(100 * scale) + moveDown, (int)(535 * scale) + moveRight, (int)(458 * scale) + moveDown); // ¾ó±¼
        SelectObject(hdc, mouse);
        Ellipse(hdc, (int)(315 * scale) + moveRight, (int)(300 * scale) + moveDown, (int)(365 * scale) + moveRight, (int)(380 * scale) + moveDown); // ÀÔ

        SelectObject(hdc, white);
        Ellipse(hdc, (int)(270 * scale) + moveRight, (int)(290 * scale) + moveDown, (int)(340 * scale) + moveRight, (int)(345 * scale) + moveDown); // ÄÚ¿ÞÂÊ
        Ellipse(hdc, (int)(340 * scale) + moveRight, (int)(290 * scale) + moveDown, (int)(410 * scale) + moveRight, (int)(345 * scale) + moveDown); // ÄÚ ¿À¸¥ÂÊ
        SelectObject(hdc, black);
        Ellipse(hdc, (int)(320 * scale) + moveRight, (int)(275 * scale) + moveDown, (int)(365 * scale) + moveRight, (int)(315 * scale) + moveDown); // ÄÚ
        Ellipse(hdc, (int)(185 * scale) + moveRight, (int)(240 * scale) + moveDown, (int)(195 * scale) + moveRight, (int)(260 * scale) + moveDown); // ¿ÞÂÊ´«
        Ellipse(hdc, (int)(490 * scale) + moveRight, (int)(240 * scale) + moveDown, (int)(500 * scale) + moveRight, (int)(260 * scale) + moveDown); // ¿À¸¥ÂÊ´«
        SelectObject(hdc, white);
        Ellipse(hdc, (int)(187 * scale) + moveRight, (int)(245 * scale) + moveDown, (int)(193 * scale) + moveRight, (int)(255 * scale) + moveDown); // ¿ÞÂÊ´«
        Ellipse(hdc, (int)(492 * scale) + moveRight, (int)(245 * scale) + moveDown, (int)(498 * scale) + moveRight, (int)(255 * scale) + moveDown); // ¿À¸¥ÂÊ´«

        MoveToEx(hdc, (int)(255 * scale) + moveRight, (int)(300 * scale) + moveDown, NULL); // ¿ÞÂÊ¼ö¿°1
        LineTo(hdc, (int)(295 * scale) + moveRight, (int)(310 * scale) + moveDown); //
        MoveToEx(hdc, (int)(255 * scale) + moveRight, (int)(340 * scale) + moveDown, NULL); // ¿ÞÂÊ ¼ö¿°2
        LineTo(hdc, (int)(295 * scale) + moveRight, (int)(320 * scale) + moveDown); //

        MoveToEx(hdc, (int)(430 * scale) + moveRight, (int)(300 * scale) + moveDown, NULL); // ¿À¸¥ÂÊ ¼ö¿°1
        LineTo(hdc, (int)(380 * scale) + moveRight, (int)(310 * scale) + moveDown); //
        MoveToEx(hdc, (int)(430 * scale) + moveRight, (int)(340 * scale) + moveDown, NULL); // ¿À¸¥ÂÊ ¼ö¿°2
        LineTo(hdc, (int)(380 * scale) + moveRight, (int)(320 * scale) + moveDown); //

        DeleteObject(face);
        DeleteObject(black);
        DeleteObject(white);
        DeleteObject(mouse);
        SelectObject(hdc, hOldPen); // ÀÌÀü Ææ ¼±ÅÃ
        DeleteObject(hPen); // Ææ »èÁ¦
    }
    if (isBoxVisible == true && isPressSpace == true) {


        HPEN hPen = CreatePen(PS_SOLID, 2, RGB(0, 0, 0));
        HPEN hOldPen = (HPEN)SelectObject(hdc, hPen);
        HBRUSH face = CreateSolidBrush(RGB(127, 200, 255));
        HBRUSH black = CreateSolidBrush(RGB(0, 0, 0));
        HBRUSH white = CreateSolidBrush(RGB(255, 255, 255));
        HBRUSH mouse = CreateSolidBrush(RGB(255, 150, 255));
        SelectObject(hdc, face);
        Ellipse(hdc, (int)(150 * scale) + moveRight, (int)(100 * scale) + moveDown, (int)(535 * scale) + moveRight, (int)(458 * scale) + moveDown); //¾ó±¼
        SelectObject(hdc, mouse);
        Ellipse(hdc, (int)(315 * scale) + moveRight, (int)(300 * scale) + moveDown, (int)(365 * scale) + moveRight, (int)(380 * scale) + moveDown); //ÀÔ

        SelectObject(hdc, white);
        Ellipse(hdc, (int)(270 * scale) + moveRight, (int)(290 * scale) + moveDown, (int)(340 * scale) + moveRight, (int)(345 * scale) + moveDown); // ÄÚ¿ÞÂÊ
        Ellipse(hdc, (int)(340 * scale) + moveRight, (int)(290 * scale) + moveDown, (int)(410 * scale) + moveRight, (int)(345 * scale) + moveDown); // ÄÚ ¿À¸¥ÂÊ
        SelectObject(hdc, black);

        Ellipse(hdc, (int)(320 * scale) + moveRight, (int)(275 * scale) + moveDown, (int)(365 * scale) + moveRight, (int)(315 * scale) + moveDown); // ÄÚ 

        MoveToEx(hdc, (int)(185 * scale) + moveRight, (int)(240 * scale) + moveDown, NULL); // ¿ÞÂÊ ´«
        LineTo(hdc, (int)(200 * scale) + moveRight, (int)(260 * scale) + moveDown); //
        MoveToEx(hdc, (int)(200 * scale) + moveRight, (int)(260 * scale) + moveDown, NULL); // ¿À¸¥ÂÊ ´«
        LineTo(hdc, (int)(185 * scale) + moveRight, (int)(280 * scale) + moveDown); //

        MoveToEx(hdc, (int)(505 * scale) + moveRight, (int)(240 * scale) + moveDown, NULL); // ¿À¸¥ÂÊ ¼ö¿°1
        LineTo(hdc, (int)(490 * scale) + moveRight, (int)(260 * scale) + moveDown); //
        MoveToEx(hdc, (int)(490 * scale) + moveRight, (int)(260 * scale) + moveDown, NULL); // ¿À¸¥ÂÊ ¼ö¿°2
        LineTo(hdc, (int)(505 * scale) + moveRight, (int)(280 * scale) + moveDown); //

        MoveToEx(hdc, (int)(255 * scale) + moveRight, (int)(300 * scale) + moveDown, NULL); // ¿ÞÂÊ¼ö¿°1
        LineTo(hdc, (int)(295 * scale) + moveRight, (int)(310 * scale) + moveDown); //
        MoveToEx(hdc, (int)(255 * scale) + moveRight, (int)(340 * scale) + moveDown, NULL); // ¿ÞÂÊ ¼ö¿°2
        LineTo(hdc, (int)(295 * scale) + moveRight, (int)(320 * scale) + moveDown); //

        MoveToEx(hdc, (int)(430 * scale) + moveRight, (int)(300 * scale) + moveDown, NULL); // ¿À¸¥ÂÊ ¼ö¿°1
        LineTo(hdc, (int)(380 * scale) + moveRight, (int)(310 * scale) + moveDown); //
        MoveToEx(hdc, (int)(430 * scale) + moveRight, (int)(340 * scale) + moveDown, NULL); // ¿À¸¥ÂÊ ¼ö¿°2
        LineTo(hdc, (int)(380 * scale) + moveRight, (int)(320 * scale) + moveDown); //

        DeleteObject(face);
        DeleteObject(black);
        DeleteObject(white);
        DeleteObject(mouse);
        SelectObject(hdc, hOldPen); // ÀÌÀü Ææ ¼±ÅÃ
        DeleteObject(hPen); // Ææ »èÁ¦
    }
}
void drawryan(HWND hWnd, HDC hdc ,int left, int top, int right, int bottom){
    RECT circle;
    GetClientRect(hWnd, &circle);

    int moveRight = 110; //¿À¸¥ÂÊÀ¸·Î ÀÌµ¿ÇÒ ÇÈ¼¿ ¼ö
    int moveDown = 25; // ¾Æ·¡·Î ÀÌµ¿ÇÒ ÇÈ¼¿ ¼ö
    float scale = 0.8; 
   
        HPEN hPen = CreatePen(PS_SOLID, 2, RGB(0, 0, 0));
        HPEN hOldPen = (HPEN)SelectObject(hdc, hPen);
        HBRUSH face = CreateSolidBrush(RGB(255, 200, 15));
        HBRUSH black = CreateSolidBrush(RGB(0, 0, 0));
        HBRUSH white = CreateSolidBrush(RGB(255, 255, 255));

        SelectObject(hdc, face);
        Ellipse(hdc, (int)(150 * scale) + moveRight, (int)(85 * scale) + moveDown, (int)(320 * scale) + moveRight, (int)(250 * scale) + moveDown);// ¿ÞÂÊ±Í
        Ellipse(hdc, (int)(365 * scale) + moveRight, (int)(85 * scale) + moveDown, (int)(535 * scale) + moveRight, (int)(250 * scale) + moveDown);// ¿À¸¥ÂÊ±Í
        Ellipse(hdc, (int)(150 * scale) + moveRight, (int)(100 * scale) + moveDown, (int)(535 * scale) + moveRight, (int)(458 * scale) + moveDown);// ¾ó±¼
        SelectObject(hdc, white);
        Ellipse(hdc, (int)(270 * scale) + moveRight, (int)(290 * scale) + moveDown, (int)(340 * scale) + moveRight, (int)(345 * scale) + moveDown); // ÄÚ¿ÞÂÊ
        Ellipse(hdc, (int)(340 * scale) + moveRight, (int)(290 * scale) + moveDown, (int)(410 * scale) + moveRight, (int)(345 * scale) + moveDown); // ÄÚ ¿À¸¥ÂÊ
        SelectObject(hdc, black);
        Ellipse(hdc, (int)(235 * scale) + moveRight, (int)(240 * scale) + moveDown, (int)(255 * scale) + moveRight, (int)(260 * scale) + moveDown); // ¿ÞÂÊ´«
        Ellipse(hdc, (int)(430 * scale) + moveRight, (int)(240 * scale) + moveDown, (int)(450 * scale) + moveRight, (int)(260 * scale) + moveDown); // ¿À¸¥ÂÊ´«
        SelectObject(hdc, black);
        MoveToEx(hdc, (int)(210 * scale) + moveRight, (int)(207 * scale) + moveDown, NULL); // ¿ÞÂÊ ´«½ç1
        LineTo(hdc, (int)(280 * scale) + moveRight, (int)(207 * scale) + moveDown); //
        MoveToEx(hdc, (int)(210 * scale) + moveRight, (int)(210 * scale) + moveDown, NULL); // ¿ÞÂÊ ´«½ç2
        LineTo(hdc, (int)(280 * scale) + moveRight, (int)(210 * scale) + moveDown); //
        MoveToEx(hdc, (int)(210 * scale) + moveRight, (int)(214 * scale) + moveDown, NULL); // ¿ÞÂÊ ´«½ç3
        LineTo(hdc, (int)(280 * scale) + moveRight, (int)(214 * scale) + moveDown); //
        MoveToEx(hdc, (int)(480 * scale) + moveRight, (int)(207 * scale) + moveDown, NULL); // ¿À¸¥ÂÊ ´«½ç1
        LineTo(hdc, (int)(410 * scale) + moveRight, (int)(207 * scale) + moveDown); //
        MoveToEx(hdc, (int)(480 * scale) + moveRight, (int)(210 * scale) + moveDown, NULL); // ¿À¸¥ÂÊ ´«½ç2
        LineTo(hdc, (int)(410 * scale) + moveRight, (int)(210 * scale) + moveDown); //
        MoveToEx(hdc, (int)(480 * scale) + moveRight, (int)(214 * scale) + moveDown, NULL); // ¿À¸¥ÂÊ ´«½ç3
        LineTo(hdc, (int)(410 * scale) + moveRight, (int)(214 * scale) + moveDown); //


        DeleteObject(face);
        DeleteObject(black);
        DeleteObject(white);
        SelectObject(hdc, hOldPen); // ÀÌÀü Ææ ¼±ÅÃ
        DeleteObject(hPen); // Ææ »èÁ¦
  
}
void DrawRyan(HDC hdc, POINT start, POINT end) {
    // ¿©±â¿¡¼­ drawryan ÇÔ¼ö È£Ãâ
    int left = min(start.x, end.x);
    int top = min(start.y, end.y);
    int right = max(start.x, end.x);
    int bottom = max(start.y, end.y);

    drawryan(hWnd, hdc, left, top, right, bottom);
}
LRESULT CALLBACK WndProc(HWND, UINT, WPARAM, LPARAM);

int APIENTRY WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow)
{
    WNDCLASS wc = { 0 };
    wc.lpfnWndProc = WndProc;
    wc.hInstance = hInstance;
    wc.lpszClassName = L"MyWindowClass";
    wc.style = CS_HREDRAW | CS_VREDRAW;

    // WinMain ÇÔ¼ö ³»¿¡¼­ Ä¿¼­ ÇÚµéÀ» ·ÎµåÇÕ´Ï´Ù.
    hCursorArrow = LoadCursor(NULL, IDC_ARROW);
    RegisterClass(&wc);

    hWnd = CreateWindow(L"MyWindowClass", L"Áß°£°í»ç", WS_OVERLAPPED | WS_CAPTION | WS_SYSMENU, 0, 0, 800, 480, NULL, NULL, hInstance, NULL);

    if (!hWnd)
        return 0;

    SetWindowLong(hWnd, GWL_STYLE, GetWindowLong(hWnd, GWL_STYLE) & ~WS_SIZEBOX);

    // ¹è°æ»ö ºê·¯½Ã »ý¼º
    hBackgroundBrush = CreateSolidBrush(viewColor);

    // Å×µÎ¸® Ææ »ý¼º
    hBorderPen = CreatePen(PS_SOLID, 1, RGB(0, 0, 0));

    // ¹öÆ° 1 »ý¼º
    CreateWindow(L"BUTTON", L"Box", WS_CHILD | WS_VISIBLE | BS_PUSHBUTTON, 36, 26, 130, 48, hWnd, (HMENU)BUTTON_ID_1, hInst, NULL);

    // ¹öÆ° 2 »ý¼º
    CreateWindow(L"BUTTON", L"Circle", WS_CHILD | WS_VISIBLE | BS_PUSHBUTTON, 36 + 130 + 16, 26, 130, 48, hWnd, (HMENU)BUTTON_ID_2, hInst, NULL);

    // ¹öÆ° 3 »ý¼º
    CreateWindow(L"BUTTON", L"BonoBono", WS_CHILD | WS_VISIBLE | BS_PUSHBUTTON, 36 + (130 + 16) * 2, 26, 130, 48, hWnd, (HMENU)BUTTON_ID_3, hInst, NULL);

    // ¹öÆ° 4 »ý¼º
    CreateWindow(L"BUTTON", L"Ryan", WS_CHILD | WS_VISIBLE | BS_PUSHBUTTON, 36 + (130 + 16) * 3, 26, 130, 48, hWnd, (HMENU)BUTTON_ID_4, hInst, NULL);

    // ¹öÆ° 5 »ý¼º
    CreateWindow(L"BUTTON", L"Cube", WS_CHILD | WS_VISIBLE | BS_PUSHBUTTON, 36 + (130 + 16) * 4, 26, 130, 48, hWnd, (HMENU)BUTTON_ID_5, hInst, NULL);

    SetCursor(hCursorArrow);
    ShowWindow(hWnd, nCmdShow);
    UpdateWindow(hWnd);

    MSG msg;
    while (GetMessage(&msg, NULL, 0, 0))
    {
        TranslateMessage(&msg);
        DispatchMessage(&msg);
    }

    // ¸®¼Ò½º Á¤¸®
    DeleteObject(hBackgroundBrush);
    DeleteObject(hBorderPen);

    return (int)msg.wParam;
}

LRESULT CALLBACK WndProc(HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam)
{
    switch (message)
    {
    case WM_CREATE:
    {
        // ¹è°æ»ö ¼³Á¤
        HBRUSH hBrush = CreateSolidBrush(viewColor);
        SetClassLongPtr(hWnd, GCLP_HBRBACKGROUND, (LONG_PTR)hBrush);
        return 0;
    }
    case WM_CLOSE:
        DestroyWindow(hWnd);
        return 0;
    case WM_DESTROY:
        PostQuitMessage(0);
        return 0;

    case WM_SETCURSOR:
    {
        // ¸¶¿ì½º Ä¿¼­ÀÇ ÇöÀç À§Ä¡¸¦ È­¸é ÁÂÇ¥·Î °¡Á®¿É´Ï´Ù.
        POINT cursorPos;
        GetCursorPos(&cursorPos);
        ScreenToClient(hWnd, &cursorPos);

        RECT clientRect;
        GetClientRect(hWnd, &clientRect);
        int margin = 8;
        int padding = 8;
        int width = clientRect.right - clientRect.left - 2 * margin - 2 * padding;
        int height = clientRect.bottom - clientRect.top - 2 * margin - 2 * padding;
        int innerMargin = 18;  // »õ·Î¿î »ç°¢Çü°ú Å×µÎ¸® °£°Ý
        int innerWidth = width - 2 * innerMargin;
        int innerHeight = 320;  // »ç°¢ÇüÀÇ ³ôÀÌ
        int innerX = margin + padding + innerMargin;
        int innerY = margin + padding + height - innerMargin - innerHeight;

        RECT rect;
        // µå·ÎÀ× ¿µ¿ªÀÇ ÁÂÇ¥¸¦ Á¤ÀÇÇÕ´Ï´Ù. ¾Æ·¡ÀÇ ÁÂÇ¥´Â ¿¹½Ã·Î Á¦°øµÇ¸ç ÀûÀýÇÑ ÁÂÇ¥·Î ¼öÁ¤ÇØ¾ß ÇÕ´Ï´Ù.
        int left = margin + padding + innerMargin;
        int top = margin + padding + height - innerMargin - innerHeight;
        int right = left + innerWidth;
        int bottom = top + innerHeight;

        // ¸¶¿ì½º Ä¿¼­ÀÇ À§Ä¡°¡ µå·ÎÀ× ¿µ¿ª ³»¿¡ ÀÖ´ÂÁö È®ÀÎ
        if (cursorPos.x >= left && cursorPos.x <= right && cursorPos.y >= top && cursorPos.y <= bottom)
        {
            SetCursor(LoadCursor(NULL, IDC_CROSS)); // µå·ÎÀ× ¿µ¿ª ³»¿¡ ÀÖ´Ù¸é CROSS Ä¿¼­·Î ¼³Á¤
        }
        else
        {
            SetCursor(hCursorArrow); // µå·ÎÀ× ¿µ¿ª ¹Û¿¡ ÀÖ´Ù¸é ±âº» Ä¿¼­·Î ¼³Á¤
        }

        return TRUE; // Ä¿¼­°¡ ¼³Á¤µÇ¾úÀ½À» ¾Ë¸³´Ï´Ù.
    }

    case WM_KEYDOWN:
        if (wParam == VK_SPACE) {
            if (!isPressSpace) { // ½ºÆäÀÌ½º¹Ù°¡ Ã³À½ ´­·ÈÀ» ¶§¸¸ ÀÛµ¿ÇÏµµ·Ï º¯°æ
                isPressSpace = true;
                InvalidateRect(hWnd, NULL, TRUE);
            }
        }
        break;
    case WM_KEYUP:
        if (wParam == VK_SPACE) {
            isPressSpace = false; // ½ºÆäÀÌ½º¹Ù°¡ ³õ¿´À» ¶§ »óÅÂ º¯°æ
            InvalidateRect(hWnd, NULL, TRUE);
        }
        break;

    case WM_PAINT:
    {
        PAINTSTRUCT ps;
        HDC hdc = BeginPaint(hWnd, &ps);

        RECT clientRect;
        GetClientRect(hWnd, &clientRect);
        int margin = 8;
        int padding = 8;
        int width = clientRect.right - clientRect.left - 2 * margin - 2 * padding;
        int height = clientRect.bottom - clientRect.top - 2 * margin - 2 * padding;

        // ¹è°æ»ö Ä¥ÇÏ±â
        SelectObject(hdc, hBackgroundBrush);
        FillRect(hdc, &clientRect, hBackgroundBrush);

        // Å×µÎ¸® ±×¸®±â
        SelectObject(hdc, hBorderPen);
        Rectangle(hdc, margin + padding, margin + padding, margin + padding + width, margin + padding + height);

        // »õ·Î¿î »ç°¢Çü ±×¸®±â
        int innerMargin = 18;  // »õ·Î¿î »ç°¢Çü°ú Å×µÎ¸® °£°Ý
        int innerWidth = width - 2 * innerMargin;
        int innerHeight = 320;  // »ç°¢ÇüÀÇ ³ôÀÌ
        int innerX = margin + padding + innerMargin;
        int innerY = margin + padding + height - innerMargin - innerHeight;

        HBRUSH hInnerBrush = CreateSolidBrush(RGB(255, 255, 255));  // Èò»ö ¹è°æ
        HPEN hInnerPen = CreatePen(PS_SOLID, 1, RGB(0, 0, 0));     // °ËÁ¤»ö Å×µÎ¸®

        SelectObject(hdc, hInnerBrush);
        SelectObject(hdc, hInnerPen);

        Rectangle(hdc, innerX, innerY, innerX + innerWidth, innerY + innerHeight);

        // ¸®¼Ò½º Á¤¸®
        DeleteObject(hInnerBrush);
        DeleteObject(hInnerPen);

        drawbonobono(hWnd, hdc);
        if (isDrawing) {
            DrawRyan(hdc, startPoint, endPoint);
        }
        EndPaint(hWnd, &ps);
        return 0;
    }
    case WM_LBUTTONDOWN:
        if (wParam == MK_LBUTTON) {
            // ¿ÞÂÊ ¸¶¿ì½º ¹öÆ°ÀÌ ´­¸° °æ¿ì, ±×¸² ±×¸®±â ½ÃÀÛ
            isDrawing = true;
            startPoint.x = LOWORD(lParam);
            startPoint.y = HIWORD(lParam);
        }
        break;

    case WM_MOUSEMOVE:
        if (isDrawing) {
            // ±×¸² ±×¸®±â°¡ ÁøÇà ÁßÀÎ °æ¿ì, ³¡ ÁöÁ¡À» ¾÷µ¥ÀÌÆ®ÇÏ°í ´Ù½Ã ±×¸®±â
            endPoint.x = LOWORD(lParam);
            endPoint.y = HIWORD(lParam);
            RECT rect = { startPoint.x, startPoint.y, endPoint.x, endPoint.y };
            InvalidateRect(hWnd, &rect, TRUE);
            UpdateWindow(hWnd);
        }
        break;
   
    case WM_LBUTTONUP:
        if (isDrawing) {
            // ¿ÞÂÊ ¸¶¿ì½º ¹öÆ°ÀÌ ³õÀÎ °æ¿ì, ±×¸² ±×¸®±â ÁßÁö
            isDrawing = false;
            endPoint.x = LOWORD(lParam);
            endPoint.y = HIWORD(lParam);
            RECT rect = { startPoint.x, startPoint.y, endPoint.x, endPoint.y };
            InvalidateRect(hWnd, &rect, TRUE);
            UpdateWindow(hWnd);
        }
        break;

    case WM_COMMAND:
    {
        // ¹öÆ° Å¬¸¯ ÀÌº¥Æ® Ã³¸®
        if (HIWORD(wParam) == BN_CLICKED)
        {
            int buttonID = LOWORD(wParam);
            switch (buttonID)
            {
            case BUTTON_ID_1:
                // ¹öÆ° 1 Å¬¸¯ Ã³¸®
                MessageBox(hWnd, L"Box Clicked", L"Button Clicked", MB_OK);
                break;
            case BUTTON_ID_2:
                // ¹öÆ° 2 Å¬¸¯ Ã³¸®
                MessageBox(hWnd, L"Circle", L"Button Clicked", MB_OK);
                break;
            case BUTTON_ID_3:
                isBoxVisible = !isBoxVisible; // º¸³ëº¸³ë Ç¥½Ã »óÅÂ¸¦ º¯°æ (º¸ÀÌ¸é ¼û±â°í, ¼û°ÜÁ® ÀÖÀ¸¸é º¸ÀÌ°Ô º¯°æ)
                InvalidateRect(hWnd, NULL, TRUE);
                break;
            case BUTTON_ID_4:
                // ¹öÆ° 4 Å¬¸¯ Ã³¸®
                isDrawing = true;
                break;
            case BUTTON_ID_5:
                // ¹öÆ° 5 Å¬¸¯ Ã³¸®
                MessageBox(hWnd, L"Cube Clicked", L"Button Clicked", MB_OK);
                break;
            }
        }
        return 0;
    }
    default:
        return DefWindowProc(hWnd, message, wParam, lParam);
    }
    return 0;
}